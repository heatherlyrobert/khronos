." heatherly hand crafted (like a dope)
."
." sections, break up the document into pieces
."   .SH <str>   begin a new section
."   .SS <str>   begin a new sub-section
."
." paragraphs, if not special formatting is used, these are unnecessary
."   .PP         before a set of contiguous lines will run them together into
."               a single paragraph -- helps if macros separate by accident
."   .RS <n>     start a paragraph indented by <n> characters (i use 3 mostly)
."   .RE         end that relative paragraph
."   .IP <str>   uses <str> as an outdent and the next line is indented
."   .TP         tag paragraph which has a more controllable outdent than .IP
."   .HP         start hanging paragraph where all following lines are indented
."
."
."
."
."
.TH khronos 1 2010-Dec "linux" "heatherly custom tools manual"

.SH NAME
khronos \- fast, simplified, modernized, and technical time-based process scheduler

.SH SYNOPSIS
.nf
.B khronos [OPTIONS]
.nf

.SH DESCRIPTION (short)
khronos is a fast, simplified, modernized, and technical version of the
classic posix-defined crond time-based process scheduler that combines both
crond and crontab to allow deeper verification, flexibility, and traceablity.

.SH DESCRIPTION (backstory)
crond is a well-worn, familiar, time-tested, and posix-defined daemon that
provides time-based job scheduling.  while this is just one aspect of batch
automation, it is the most commonly used and crond does it exceptionally
well.  many attempts have been made to "do it better", but its still here.

brian kernighan nailed it in the original (1979) by focusing on a real and
definite need by folks that understood automation on low power systems.  he
coupled it with an elegant, expressive, and terse scheduling grammar built
by computer science folks and kept it simple and robust.  bloody brilliant.

but, there are now many implementations of crond screaming out for use,
each of which comes with its own set of creeping featurism, cruft, and
accessibility "improvements."  they all just tend to piss me off as
everything seems to be trending towards the closely coupled, gui-focused,
kitchen-sink mentality that then tends to display well but never gets used.

the one thing the advancements, since the original, truly improved were the
algorithms.  the original cron apparently could not scale to a large
number of users, not that helpful for them.  in our case, we won't have a
ton of different users, but we will have tons of jobs running -- we want
the better algorithms to make up for the primitiveness of our coding ;)

khronos will attempt to implement the original simplicity, clarity, and
power with updated algorithms, automated testing, strong logging and
monitoring, stronger security, and a few added recovery/notification
features.  we will maintain much backward compatibility while focusing on
an automation-intensive, power-user environment for our own personal use.

"do one thing and do it well (securely) and focus on technical users"

khronos will provide...
   - near posix compatibility to do the full job on core features
   - backwards compatible with existing crontab formats (great design)
   - additional, specific job recovery features (better lights out)
   - strict glibc/ansi-c so it can be ported to and compilied anywhere
   - fast and efficient because we want to enable tons of automation
   - solid logging and status updates so you never have to guess
   - ablilty to be very verbose in interactive use also (tracing)
   - clean, clear code so we can maintain it after long absences
   - fullsome unit testing and regression testing suite
   - eliminate known and potential security gaps and hacking vectors
   - ability to test/verify crontabs before installation

khronos will not provide...
   - automatic email -- everyone ultimately hates it (security risk)
   - alternate shells (we're gonna run pure posix dash)
   - extended shell variables (gonna have a spartan shell environment)
   - run-time configuration (no, its only for us, we can update code)
   - names for days and months, just use the numbers and like it ;)
   - special symbols for easly expressible things (@hourly, @weekly)

khronos will break backward compatiblilty in the following areas...
   - crontabs will be stored in /var/spool/crontabs (not a big deal)
   - crontab names will allow for many files per user (like dcron)
   - crontabs will only be pulled from ~/c_quani/crontabs (std for us)
   - not allow -c option as it is a security nightmare (no way)
   - not allow -e option as it is a traceablilty nightmare (no loss)
   - not allow - option as it is even worse thatn -e (who cares)
   - no mail at all (we will use other features to do it right)

on a large scale, khronos will not provide...
   - dependency-based scheduling (like init systems provide)
   - event-based launches like @reboot (daemons should do this)
   - resource-based changes to schedules, system load, or avail

we don't want to just use the system, we want to *own* it; so that means
we have to fundmentally understand the critical services which only tearing
down and rebuilding can really teach -- even if its more basic in the end.

as luck would have it, dcron (dillon's cron) is a wonderfully straight
forward and clean implementation that we can learn from.  it is licenced
under the gnu gpl and so is perfect as our base.  so, we study dcron...

so, as always, there are many stable, accepted, existing programs and
utilities written by better programmers which are likely superior in
speed, size, capability, and reliability; BUT, i would not have learned
nearly as much just using them, so i follow the adage..

TO TRULY LEARN> do not seek to follow in the footsteps of the men of old;
seek what they sought ~ Matsuo Basho

at the end of the day, this is wicked critical and deserves the attention.
it is also full of learning opportunities ;)

.SH OPTIONS

.B khronos
run without options launches the process scheduling daemon if one is not
already running (only one can run at a time).  it then reads all installed
crontab files, inventories the list of schedule entries, and runs them at
the appropriate time.

when options are included
.B khronos
runs in interactive mode and allows anyone to work with their respective
crontab files -- installing, deleting, purging, listing, etc.

the following options are posix-defined and implemented...

.B <desc>
.RS 8
installs a crontab with the description listed into the systems crontab spool
directory and notifies khronos to read it for immediate processing.
.RE

.B -r <desc>,
.B -d <desc>
.RS 8
deletes a crontab with the description listed from the systems crontab spool
directory, stops it jobs, and notifies khronos to removed it inactive.
.RE

.B -u <user>
.RS 8
allows the super-user to act for another user to install, delete, purge,
reload, etc their crontab jobs. this is only supported for root.
.RE

.B -l
.RS 8
list the contents of all the users installed crontabs to stdout.  in the
posix version, this was singular, but we allow multiple.
.RE

the following options are posix-defined and NOT implemented...

.B -c <dir>
.RS 8
NOT ALLOWED.  in the posix version, this allowed the super-user to change the
crontab directory which cron read from -- huge security risk.
.RE

.B -e <desc>
.RS 8
NOT ALLOWED.  in the posix version, this allowed a user to immediately edit an
installed crontab, but left no file to be backed up -- no traceability.
.RE

.B -
.RS 8
NOT ALLOWED.  in the posix version, this allowed a user to install their
crontab from stdin, but left to backup -- huge security risk.
.RE

the following options have been added to our version (non-posix)...

.B --test <desc>
.RS 8
this is an advancement on the installation above as it tests the crontab entries
using the actual khronos code to give the user essentially a compilation.
.RE

.B --here
.RS 8
lists the names of all the local crontabs that could be installed by the current
user.  this will avoid having to travel to the directory and list them.
.RE

.B --list
.RS 8
lists the names of all installed crontabs by the current user.  this can be
very handy for confirmation purposes.
.RE

.B --all
.RS 8
this is a version of "--list" for the super-user that lists all the crontabs
installed by any user.  another time saver.
.RE

.B --purge
.RS 8
delete all the installed crontabs by the current user as if each was
requested using "-r" one at a time.
.RE

.B --cleanse
.RS 8
this is a version of "--purge" for the super-user that deletes all crontabs
no matter what user installed them.  good for a graceful slowdown.
.RE

.B --reload
.RS 8
this option deletes all installed crontabs by the current user and then
installs all that they have in their local directory.  another time saver.
.RE

.B --help, -h
.RS 8
this provides a page of one-lines on each option khronos accepts and a little
background on the tool.
.RE

.SH SCHEDULING GRAMMAR

.B khronos
the magic of khronos is a slightly modified form of the kernighan scheduling
grammar he implemented in the original cron in 1978.

a crontab line is composed of six scheduling grammar fields which have no
fixed length and are separated by spaces...

.B <minutes>
.RS 8
minute marks on which the job should launch (00-59)
.RE

.B <hours>
.RS 8
hours on which the job should launch (00-23)
.RE

.B <days>
.RS 8
days on which the job should launch (01-31)
.RE

.B <months>
.RS 8
months in which the job should launch (01-12)
.RE

.B <days of the week>
.RS 8
weekdays on which the job should launch (1/Mo -7/Su)
.RE

.B <weeks of the year>
.RS 8
weeks in which the job should launch (01-53)
.RE

all these fields are combined through AND logic to determine when a job is
scheduled to launch.  As a note, most crons use OR logic with day/dow and do
not include the weeks field.

each of these six fields uses the same foundational grammar...

.B wildcard (*)
.RS 8
all possible values in a field, i.e., no restriction
.RE

.B range (<nn>-<nn>)
.RS 8
all values between two numbers (inclusive)
.RE

.B step (/<nn>)
.RS 8
modifies a range or wildcard to skip by a value
.RE

.B list (<nn>,<nn>)
.RS 8
creates the union between two values, ranges, etc.
.RE

.B modifier (<nn><ch>)
.RS 8
modifies a value within its context
.RE

.B prefixes (<ch><nn>)
.RS 8
significantly modifies the value
.RE

.B constant (<ch>)
.RS 8
stands in for a value or range of values
.RE

some basic examples to explain are...

#min-- -hrs-- day--- mon--- dow--- wks---

00     02     *      *      *      *       2am every day

00     00     1      *      *      *       midnight on the first

10     *      *      *      *      *       10min after every hour

30     8,17   *      *      *      *       8:30a and 5:30p

00,30  8-17   *      *      *      *       half hours from 8a to 5p

00     12     *      *      1      *       noon every monday

00     20     *      *      5      1       8p friday in first week

00     00     31     *      *      *       midnight on jan 31st

00     00     */2    *      *      *       midnight every other day

00     3-9/3  *      *      *      *       3a, 6a, and 9a

00     15     *      *      *      */2     3p very other week

in order to make the crontab more readable, some contants may be used...

.B L (last)
.RS 8
may be used in any field, e.g., L in days is last day of month
.RE

.B B (business hours)
.RS 8
9a to 5p only (only in hours)
.RE

.B Mo, Tu, We, Th, Fr, Sa, Su (weekdays)
.RS 8
to keep it quickly readable -- can't be in ranges
.RE

.B W, E (weekdays)
.RS 8
abbreviated standin for all weekdays (W) and weekends (E)
.RE

some days are hard to specify and require modifiers...

.B <nn>a (after)
.RS 8
first weekday (Mo-Fr) on or after the date (only in days)
.RE

.B <nn>b (before)
.RS 8
closest weekday (Mo-Fr) on or before the date (only in days)
.RE

.B <nn>n (nearest)
.RS 8
nearest weekday (Mo-Fr) to date (only in days)
.RE

.B <n>w (full week)
.RS 8
stands in for 1st, 2nd, ... week of the month (only in days)
.RE

.B <n>q (full quarter)
.RS 8
stands in for 1st, 2nd, ... quarter of year (only in months)
.RE

some further examples to explain are...

#min-- -hrs-- day--- mon--- dow--- wks---

00     08     *      *      Tu,Fr  *       8a on Tuesday and Friday

00     13     *      *      W      *       1p on all weekdays

00     15     15n    *      *      *       3p workday nearest the 15th

00     15     15b    *      *      *       ... on or before the 15th

00     15     15a    *      *      *       ... on or after the 15th

00     10     2w     *      Mo     *       10a on the 2nd Monday

00     B      *      *      W      *       each bus. hour on weekday





.SH FILES

.I ~/c_quani/contabs/
.RS 3
this directory is where khronos will source the local crontabs for a specific
user -- it can not be set to do otherwise.
.RE

.I /var/spool/crontabs/
.RS 3
this is the system directory where installed crontabs are kept and khronos
reads these files when launched and sent a SIGHUP.
.RE


.SH RESOURCES
will only work with yLOG installed for khronos.

.SH AUTHOR
the_heatherlys

.SH HERITAGE
khronos is the primeval god to time, not the titan cronos who was
zeus' father (which was spelled cronos).

.SH COLOPHON
this page is part of a documentation package mean to make our use of the
heatherly tools easier and faster

