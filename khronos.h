/*=============================[[ beg-of-code ]]==============================*/


/*===[[ ONE_LINERS ]]=========================================================*/
/*-------   --12345678  "123456789-123456789-123456789-123456789-123456789-123456789-"  */

#define     P_FOCUS     "AU (system automation)"
#define     P_NICHE     "ba (batch automation)"
#define     P_SUBJECT   "time-based batch automation"
#define     P_PURPOSE   "reliable, trackable, and focused time-based job scheduling"

#define     P_NAMESAKE  "khronos-anileis (merciless time)"
#define     P_QUICK     "god of creation and unyielding time"
#define     P_HERITAGE  "incorporeal protogenoi god of creation and unyielding time"
#define     P_IMAGERY   "winged serpent (drakon) with three heads; bull, lion, and man"
#define     P_REASON    "khronos is the embodiment of the merciless march of time"

#define     P_ONELINE   P_NAMESAKE " " P_SUBJECT

#define     P_HOMEDIR   "/home/system/khronos.heatherly_cron_daemon"
#define     P_BASENAME  "khronos"
#define     P_FULLPATH  "/usr/sbin/khronos"
#define     P_SUFFIX    "khronos"
#define     P_CONTENT   "revised crontabs allowing enhanced controls"

#define     P_SYSTEM    "gnu/linux   (powerful, ubiquitous, technical, and hackable)"
#define     P_LANGUAGE  "ansi-c      (wicked, limitless, universal, and everlasting)"
#define     P_CODESIZE  "small       (appoximately 1,000 slocl)"
#define     P_DEPENDS   "ySTR,yPARSE,yDLST,yJOBS,yEXEC,ySCHED"

#define     P_AUTHOR    "heatherlyrobert"
#define     P_CREATED   "2010-05"

#define     P_VERMAJOR  "2.--, simplify and harden code"
#define     P_VERMINOR  "2.0-, streamline given eos and herakles"
#define     P_VERNUM    "2.0c"
#define     P_VERTXT    "24h by min proposed schedule report is 90p formatted"

#define     P_TOPOFMIND "wild ideas, big experimental code base, single maintainer"
#define     P_PRIORITY  "direct, simple, brief, vigorous, and lucid (h.w. fowler)"
#define     P_PRINCIPAL "[grow a set] and build your wings on the way down (r. bradbury)"
#define     P_REMINDER  "there are many better options, but i *own* every byte of this one"

/*-------   --12345678  "123456789-123456789-123456789-123456789-123456789-123456789-"  */
/*===[[ END ONE_LINERS ]]=====================================================*/

/*3456789-123456789-123456789-123456789-123456789-123456789-123456789-123456789- */
#define     P_DEFINE    "niche definition¦" \
   "batch automation is shifting of workloads across time and space to balance,¦" \
   "optimize, and maximize the use of available schedule, processing capacity,¦" \
   "storage media, and human interaction time.  sub-disciplines include...¦" \
   " -- time-based, common and easy (usually down to minutes, ranges)¦" \
   " -- resource-based, rear window (cpu, disk, fragmentation, ...)¦" \
   " -- event-based, easy but simplistic (reboot, hibernate, ...)¦" \
   " -- user-triggered (activity, meetings, lunch, leave for day, ...)¦" \
   " -- predictive (based on past usage, normal schedules, routines)¦" \
   " -- plus, multi-machine coordination and load-balancing¦"

/*3456789-123456789-123456789-123456789-123456789-123456789-123456789-123456789- */
#define     P_POTENTIAL "potential value¦" \
   "modern systems environments make deplorable use of resources.  typically¦" \
   "sized for interactive and peak loads, therefore wildly underutilized ninety-¦" \
   "five percent of the time, even likely fully idle over half the time.¦"

/*3456789-123456789-123456789-123456789-123456789-123456789-123456789-123456789- */
#define     P_SCOPE     "specific scope¦" \
   "time-based job scheduling is the most common and scalable aspect of batch¦" \
   "automation, focusing on manually balancing workload by launching tasks¦" \
   "based on expected (not real) availability.¦"

/*  123456789-123456789-123456789-123456789-123456789-123456789-123456789-123456789- */
#define     P_EXAMPLE   "prototype/model¦" \
   "kernighan's crond (1979) is a well-worn, heavily-used, posix-defined daemon¦" \
   "that does time-based job scheduling exceptionally well -- focused on real¦" \
   "needs, power users, elegant scheduling grammar, and low-power systems.¦"

/*3456789-123456789-123456789-123456789-123456789-123456789-123456789-123456789- */
#define     P_TROUBLE   "why it doesn't work¦" \
   "there are many usable tools written for batch automation, but people just¦" \
   "don't get it anymore.  computers are cheap, designers don't try, and real¦" \
   "need is rare so computers sit doing nothing, just like their owners.¦"

/*3456789-123456789-123456789-123456789-123456789-123456789-123456789-123456789- */
#define     P_NEWMIND   "change in thinking¦" \
   "almost nothing changes in a single day.  you edit one percent of your files,¦" \
   "update one or two programs, and maybe acquire some new content. almost all¦" \
   "updates can be done overnight.  real-time is reserved for critical things.¦"

/*3456789-123456789-123456789-123456789-123456789-123456789-123456789-123456789- */
#define     P_SUMMARY   "summary¦" \
   "khronos is a personal, simplified, traceable, and technical version of the¦" \
   "classic posix-defined crond time-based job scheduler that strips away modern¦" \
   "cruftiness and targets transparency and maintainability.¦"

/*3456789-123456789-123456789-123456789-123456789-123456789-123456789-123456789- */
#define     P_GREEK     "greek heritage¦" \
   "khronos-ageraton (unaging) is the primeval, protogenoi god of time who¦" \
   "emerged self-formed at the beginning of everything.  khronos is an¦" \
   "incorporial god in serpentine form (drakon) with wings on its shoulders¦" \
   "and three heads -- that of a man, a bull, and a lion.¦" \
   "···¦" \
   "khronos' consort is ananke (inevitability and compulsion) who was also¦" \
   "serpentine.  together they created the ordered universe and continue to¦" \
   "circle it in their coils thereby driving the movement of the heavens and¦" \
   "the wind/passage of time.¦" \
   "···¦" \
   "khronos and ananke gave birth to aither (light), unbounded khaos (chasm),¦" \
   "and erebos (darkness).  khronos and ananke also created the world-egg and¦" \
   "split it into earth (gaea), sea (hydros), and sky (ouranos).¦" \




/*   NEXT STEPS
 *
 *   1) add system impact indicators for cpu, disk, and network
 *      -- maybe 0 none, 1 trivial, 2 low, 3 medium, 4 high, 5 maxing out
 *      -- this could be added to job spec [--·---·cdn]
 *
 *   2) khronos to read system use flag from sysadmin to make decisions
 *      -- note is every 5, 6, or 10 minutes
 *      -- indicates what system is using and for how long, like "going to lunch"
 *      -- value Absolute and Need will run, may be delayed or fulled forward
 *      -- value Value, Crave, and Want are optional (maybe one day miss?)
 *      -- value Like, Might, and Unset are just skipped as needed
 *
 *   3) monitor the system usage database from SA that runs every 2 minutes
 *      -- predict system load based on other days
 *      -- give an indication of present load and use to delay
 *
 *   4) temporary black-out periods, for downtime, maintenance, emergencies
 *      -- somehow tell khronos to run nothing
 *      -- maybe just kill the daemon
 *
 *   5) specific no-run or cancel, e.g., don't run helios today
 *      -- trouble this is not for all entries in file
 *      -- could update actual cronfile, but how to remember to fix later
 *      -- could be command-line, but no auditing
 *      -- like file update with "exception" verb with dates and a *reason*
 *      -- all exceptions appear after the crontab entry to appear readable
 *      -- exceptions are valid for one crontab entry only
 *      -- write the exception to the log when encountered (for backup)
 *
 *   6) bring back "black-out" list of dates at top of crontab
 *      -- maybe make a line per with a *reason* for documentation
 *
 *
 *
 */


/*
 *   DESIGN DECISIONS
 *
 *   create a separate spool directory called khronos, rather than use cron
 *   -- other programs then can not auto-create batch jobs (security)
 *   -- if both are used on a system, no conflicts
 *
 *   support the original format, but also a enhanced one
 *   -- the original format is quick and easy
 *   -- the enhanced/revised one allows many more controls
 *
 *
 *
 *
 *
 *
 *
 */


/*> .SH DESCRIPTION (backstory)                                                       <* 
 *> crond is a well-worn, familiar, time-tested, and posix-defined daemon that        <* 
 *> provides time-based job scheduling.  while this is just one aspect of batch       <* 
 *> automation, it is the most commonly used and crond does it exceptionally          <* 
 *> well.  many attempts have been made to "do it better", but its still here ;)      <* 
 *>                                                                                   <* 
 *> brian kernighan nailed it in the original (1979) by focusing on a real and        <* 
 *> definite need by folks that understood automation on low power systems.  he       <* 
 *> coupled it with an elegant, expressive, and terse scheduling grammar built        <* 
 *> by computer science folks and kept it simple and robust.  bloody brilliant.       <* 
 *>                                                                                   <* 
 *> but, there are now many implementations of crond screaming out for use,           <* 
 *> each of which comes with its own set of creeping featurism, cruft, and            <* 
 *> accessibility "improvements."  they all just tend to piss me off as               <* 
 *> everything seems to be trending towards the closely coupled, gui-focused,         <* 
 *> kitchen-sink mentality that then tends to display well but never gets used.       <* 
 *>                                                                                   <* 
 *> the one thing these advancements truly improved were the algorithms.              <* 
 *> the original cron apparently could not scale to a large number of users --        <* 
 *> not that helpful for them.  in our case, we won't have a ton of different         <* 
 *> users, but we will have tons of jobs running -- we want the better algorithms     <* 
 *> to make up for the primitiveness of our coding ;)                                 <* 
 *>                                                                                   <* 
 *> khronos will attempt to implement the original simplicity, clarity, and           <* 
 *> power with updated algorithms, automated testing, strong logging and              <* 
 *> monitoring, stronger security, and a few added recovery/notification              <* 
 *> features.  we will maintain much backward compatibility while focusing on         <* 
 *> an automation-intensive, power-user environment for our own personal use.         <* 
 *>                                                                                   <* 
 *> "do one thing and do it well (securely) and focus on technical users"             <* 
 *>                                                                                   <* 
 *> khronos will provide...                                                           <* 
 *>    - near posix compatibility to do the full job on core features                 <* 
 *>    - backwards compatible with existing crontab formats (great design)            <* 
 *>    - additional, specific job recovery features (better lights out)               <* 
 *>    - strict glibc/ansi-c so it can be ported to and compilied anywhere            <* 
 *>    - fast and efficient because we want to enable tons of automation              <* 
 *>    - solid logging and status updates so you never have to guess                  <* 
 *>    - ablilty to be very verbose in interactive use also (tracing)                 <* 
 *>    - clean, clear code so we can maintain it after long absences                  <* 
 *>    - fullsome unit testing and regression testing suite                           <* 
 *>    - eliminate known and potential security gaps and hacking vectors              <* 
 *>    - ability to test/verify crontabs before installation                          <* 
 *>                                                                                   <* 
 *> khronos will not provide...                                                       <* 
 *>    - automatic email -- everyone ultimately hates it (security risk)              <* 
 *>    - alternate shells (we're gonna run pure posix dash)                           <* 
 *>    - extended shell variables (gonna have a spartan shell environment)            <* 
 *>    - run-time configuration (no, its only for us, we can update code)             <* 
 *>    - names for days and months, just use the numbers and like it ;)               <* 
 *>    - special symbols for easly expressible things (@hourly, @weekly)              <* 
 *>                                                                                   <* 
 *> khronos will break backward compatiblilty in the following areas...               <* 
 *>    - crontabs will be stored in /var/spool/crontabs (not a big deal)              <* 
 *>    - crontab names will allow for many files per user (like dcron)                <* 
 *>    - crontabs will only be pulled from ~/c_quani/crontabs (std for us)            <* 
 *>    - not allow -c option as it is a security nightmare (no way)                   <* 
 *>    - not allow -e option as it is a traceablilty nightmare (no loss)              <* 
 *>    - not allow - option as it is even worse thatn -e (who cares)                  <* 
 *>    - no mail at all (we will use other features to do it right)                   <* 
 *>                                                                                   <* 
 *> on a large scale, khronos will not provide...                                     <* 
 *>    - dependency-based scheduling (like init systems provide)                      <* 
 *>    - event-based launches like @reboot (daemons should do this)                   <* 
 *>    - resource-based changes to schedules, system load, or avail                   <* 
 *>                                                                                   <* 
 *> we don't want to just use the system, we want to *own* it; so that means          <* 
 *> we have to fundmentally understand the critical services which only tearing       <* 
 *> down and rebuilding can really teach -- even if its more basic in the end.        <* 
 *>                                                                                   <* 
 *> as luck would have it, dcron (dillon's cron) is a wonderfully straight            <* 
 *> forward and clean implementation that we can learn from.  it is licenced          <* 
 *> under the gnu gpl and so is perfect as our base.  so, we study dcron...           <* 
 *>                                                                                   <* 
 *> so, as always, there are many stable, accepted, existing programs and             <* 
 *> utilities written by better programmers which are likely superior in              <* 
 *> speed, size, capability, and reliability; BUT, i would not have learned           <* 
 *> nearly as much just using them, so i follow the adage..                           <* 
 *>                                                                                   <* 
 *> TO TRULY LEARN> do not seek to follow in the footsteps of the men of old;         <* 
 *> seek what they sought ~ Matsuo Basho                                              <* 
 *>                                                                                   <* 
 *> at the end of the day, this is wicked critical and deserves the attention.        <* 
 *> it is also full of learning opportunities ;)                                      <*/


/*===[[ SUMMARY ]]=============================================================*

 *   khronos is a fast, simplified, modernized, and technical version of the
 *   classic posix-defined crond time-based process scheduler which merges crond
 *   and crontab to allow deeper verification, verbosity, and traceablity.
 *
 */
/*===[[ PURPOSE ]]=============================================================*

 *   crond is a well-worn, familiar, time-tested, and posix-defined daemon that
 *   provides time-based job scheduling.  while this is just one aspect of batch
 *   automation, it is the most commonly used and crond does it exceptionally
 *   well.  many attempts have been made to "do it better", but its still here.
 *
 *   brian kernighan nailed it in the original (1979) by focusing on a real and
 *   definite need by folks that understood automation on low power systems.  he
 *   coupled it with an elegant, expressive, and terse scheduling grammar built
 *   by computer scientists and kept it simple and robust.  hugely brilliant.
 *
 *   but, there are now many implementations of crond screaming out for use,
 *   each of which comes with its own set of creeping featurism, cruft, and
 *   accessibility "improvements."  they all just tend to piss me off as
 *   everything seems to be trending towards the closely coupled, gui-focused,
 *   kitchen-sink mentality that then tends to display well but never gets used.
 *   i don't care if its easy for an idiot to use -- they don't use it anyway ;)
 *
 *   the one thing the advancements, since the original, truly improved were the
 *   algorithms.  the original cron apparently could not scale to a large
 *   number of users, so not that helpful for them.  in our case, we won't have
 *   a ton of different users, but we will have tons of jobs running -- we want
 *   the better algorithms to make up for the primitiveness of our coding ;)
 *
 *   khronos will attempt to implement the original simplicity, clarity, and
 *   power with updated algorithms, automated testing, strong logging and
 *   monitoring, stronger security, and a few added recovery/notification
 *   features.  we will maintain some backward compatibility while focusing on
 *   an automation-intensive, power-user environment for our own personal use.
 *
 *   "do one thing and do it well (securely) and focus on technical power users"
 *
 *   khronos will provide...
 *      - strict glibc/ansi-c so it can be ported to and compilied on anything
 *      - fast and efficient because we want to enable tons of automation
 *      - additional, specific job monitoring and recovery features
 *      - solid, verbose logging and status updates so you never have to guess
 *      - near posix compatibility so it can do the full job on core features
 *      - clean, clear code so we can maintain it after long absences
 *      - fullsome unit testing and regression testing suite
 *      - eliminate known and potential security gaps and hacking vectors
 *      - ability to test/verify crontabs before actual installation
 *
 *   khronos' crontab format will...
 *      - utilize the elegant core scheduling grammar as the original design
 *      - allow both original and the modified heatherly format
 *      - will be 98% backward compatible on the first five fields
 *      - but will use "and" to combine day of month/week (cleaner and stronger)
 *      - add a week field (6) for week-of-year (alternating, etc)
 *      - add a duration field (7) to allow khronos to know max run time
 *      - will add a year column, as admins have trouble keeping long-term notes
 *      - add a title fields for human-readable status reporting
 *      - the command/script field remains last and is now in the tenth position
 *      - add shortcuts for days of week, weekends, etc to increase readability
 *      - add duration expectations to control bad behaviour (min/max/exp)
 *      - add importance to decide what to run in recovery situations
 *
 *   khronos will not provide...
 *      - automatic email -- everyone ultimately hates it (security risk)
 *      - alternate shells (we're gonna run pure posix dash)
 *      - extended shell variables (gonna have a spartan shell environment)
 *      - run-time configuration (no, its only for us, we can update code)
 *      - special symbols for easily expressible things (@hourly, @weekly)
 *
 *   khronos will break backward compatiblilty in the following areas...
 *      - crontabs format will be expanded after the scheduling grammar part
 *      - crontabs will be stored in /var/spool/crontabs (not a big deal)
 *      - crontab names will allow for many files per user (like dcron)
 *      - crontabs will only be pulled from ~/c_quani/crontabs (std for us)
 *      - will not allow -c option as it is a security nightmare (no way)
 *      - will not allow -e option as it is a traceablilty nightmare (no loss)
 *      - will not allow - option as it is even worse than -e (who cares)
 *      - no mail at all (we will use other features to do it right)
 *
 *   on a large scale, khronos will not provide the other parts of batch work...
 *      - dependency-based scheduling (like init systems provide)
 *      - event-based launches like @reboot (daemons can and should do this)
 *      - resource-based changes to schedules, such as system load or avail
 *
 *   as a result of our changes, khronos is not a novice user tool, but neither
 *   was cron as admins can not allow crazy user processes to run all night.
 *   does anyone want users or installers to make decisions about what and when
 *   to run jobs on you system ?!#@!  really!!!
 *
 *   we don't want to just use the system, we want to *own* it; so that means
 *   we have to fundmentally understand the critical services which only tearing
 *   down and rebuilding can really teach -- even if its more basic in the end.
 *
 *   as luck would have it, dcron (dillon's cron) is a wonderfully straight
 *   forward and clean implementation that we can learn from.  it is licenced
 *   under the gnu gpl and so is perfect as our base.  so, we study dcron...
 *
 *   so, as always, there are many stable, accepted, existing programs and
 *   utilities written by better programmers which are likely superior in
 *   speed, size, capability, and reliability; BUT, i would not have learned
 *   nearly as much just using them, so i follow the adage..
 *
 *   TO TRULY LEARN> do not seek to follow in the footsteps of the men of old;
 *   seek what they sought ~ Matsuo Basho
 *
 *   at the end of the day, this is wicked critical and deserves the attention.
 *   it is also full of learning opportunities ;)
 *
 */
/*===[[ ALTERNATIVES and COMPONENTS ]]=========================================*

 *   this is a survey of current cron implementations and related tools so we
 *   can get a good sense of what's out there, what it can do, and what problems
 *   they are trying to solve...
 *
 *    sys-process/vixie-cron (57k)
 *       - "standard" cron system for linux distributions (vixie = paul vixie)
 *       - stable and reliable
 *
 *    sys-process/anacron (23k)
 *       - supplements cron to deal with variable uptime, like laptops
 *       - is run daily and looks for jobs for that day or that haven't run yet
 *       - helps with housekeeping, but doesn't schedule tighter than days
 *       - INTERESTING IDEA, we'll see about some features
 *
 *    sys-process/bcron (56k)
 *       - security focused version (b = bruce guetner)
 *       - JUST TIGHTEN THE CRON SYSTEM AS IT IS?
 *
 *    sys-process/cronie (196k)
 *       - slang for follower or yes-man
 *       - very close to the original but with PAM and SELinux enhancements
 *       - I WILL NOT GET CAUGHT IN THE PAM/SELINUX TRAP
 *
 *    kde-base/kcron (1215k)
 *       - kde's task scheduler that runs on top of cron (WTF)
 *       - can set environment variables and jobs
 *       - MASSIVE PIG AT OVER A MEG !!!! plus needs qt and kde !!!!
 *
 *    sys-process/dcron (21k)
 *       - clean, lean cron version (d = matt dillon)
 *       - great base for our code
 *
 *    sys-process/mcron (???)
 *       - written in guile/scheme craziness (m = dale mellor)
 *       - YOU GOTTA BE KIDDING ME, SCHEME ?
 *
 *    sys-process/fcron (539k)
 *       - adds "nice" settings on the job (TOO COMPLEX)
 *       - can run a job once between X and Y time (BUT HOW TO DECIDE WHEN)
 *       - can take system load average into account (not allowed over NN%)
 *       - lots of environment variable setting features (NO, NO, NO)
 *       - "@" to indicate an interval or time relative to fcron's startup (NO)
 *       - "%" to indicate "hourly", "daily", "monthly", etc (MAYBE SHORTCUTS)
 *       - '!' to set a variable like niceness, mailto, load level, etc. (NO)
 *       - allows one user running a job as another ("runas") (SECURITY RISK)
 *       - "serial" to run next jobs finish-to-start (USE BASH SCRIPT &&, ||, !)
 *       - WHOLLY COW ITS HUGE!!!
 *
 *    sys-process/incron (196k)
 *       - inotify based cron system (in = inotify)
 *       - reacts to changes in the file system
 *       - TOTALLY DIFFERENT THING, REJECTED
 *
 *    sys-process/at (96k)
 *       - set a job to run once at a specific time
 *
 *   sys-process/cronbase (---k)
 *      - appears to essentially be the "run-crons" written in shell/bash
 *      - allows jobs to be dropped in a directory and run vs. using a crontab
 *      - it makes packages easier to install and setup a simple cron job
 *      - but, also makes it easy for jobs sneaking in and circumventing review
 *      - this appears to be a "dumification" feature to me (with security risk)
 *      - REJECTED
 *
 */
/*===[[ SISO : STRICT IN, STRICT OUT ]]========================================*

 *   with many applications, the hacking and security failure exploits happen
 *   because designers and programmers try to make the input mechanisms as
 *   understanding and flexible as possible.  on the one hand, this enables
 *   applications to adapt to new uses and live forever; but, on the other, it
 *   makes them extraordinarily vulnerable to attack and misuse.
 *
 *   so, we will be using a different model where inputs are limited and
 *   validated rigorously in such that it would be more difficult to exploit.
 *
 *   basic limits...
 *      - file names : 3-71 char, [A-Za-z0-9_], with '.' separating user.desc
 *      - user names : 1-20 characters and [A-Za-z0-9_] only
 *      - descripion : 1-50 characters and [A-Za-z0-9_] only
 *      - commands   : no longer than 250 characters
 *      - records    : no longer than 250 characters
 *      - files      : unlimited per user
 *      - lines      : less than 1000 per file
 *      - VARS       : none
 *      - SHELL      : /bin/dash
 *      - PATH       : /bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin
 *
 */
/*===[[ EXAMPLES ]]============================================================*

 *   one of the major failings of the documentation and nearly all web sites
 *   about cron and crontab is the almost completely lack of real world
 *   examples.  without useful and relevant examples, many tools just die or go
 *   into disuse.  worse yet, folks start teaching other application to wake
 *   themselves up periodically to do some task -- wasting resources.
 *
 *   cleansing temp and cache directories
 *
 *   checking user accounts
 *
 *   getting latest map images on cloud cover
 *
 *   getting the latest government statistics
 *
 *   getting most recent headlines and/or news rather than continuously
 *
 *   bringing down email on regular updates
 *
 *   syncronizing local content with network sites
 *
 *   remove firefox cache files
 *
 *   hourly chimes
 *
 *   indexing files
 *
 *   checking for root kits and/or viruses
 *
 */
/*===[[ DESIGN DECISIONS ]]====================================================*

 *   crontab updates...
 *      - it is too easy to lose the original crontab entries if you can edit
 *        them with "-e" so eliminate that option
 *      - we have seen several options for triggering a reread of the crontab
 *        files in the spool directory...
 *      1 dcron saves a file called "cron.update" with a list of users that
 *        have updated their cron files (could lose the file)
 *      2 many crons change the date on the crontab directory to trigger a
 *        reread of the files (also requires crontab)
 *      3 we could save all updated crontabs with an extention of ".updated"
 *        so that we can only look for those
 *      4 we could us a prefix of on the files such as "#" and only look for
 *        because its even faster
 *      - although option four is easy, i don't like allowing special characters
 *        into file names and so we won't do it
 *      - we will suffix crontab files with ".NEW" for ones to be read and then
 *        ".DEL" for files that should be purged and then deleted
 *      - then, khronos will only respond to a SIGHUP or a restart to read the
 *        files for updates (looking only at .NEW and .DEL)
 *
 *   potential speed improvements...
 *      - what if crontab created a linked list of only the jobs that could run
 *        in the next hour so that the searching is not by file/line, but
 *        directly with the linked list
 *      - that list could then be refreshed every hour to prepare for the
 *        next period
 *      - the list could really cover any period so its just a trade off of
 *        frequency of update to the speed of the test cycle
 *
 *   monitoring...
 *      - crond is typically just a process that runs without anyone paying
 *        any attention unless jobs stop completing -- hours or days later
 *      - i would like to create a mechanism whereby cron can somehow make it
 *        obvious if it is not running (someone watching the watcher ;)
 *      - i would also like to have an easy time knowing when cron was up and
 *        active versus down without manual work or research required
 *
 *   crontab editing...
 *      - i really don't like using crontab to edit the crontabs directly in the
 *        spool directory as it does not result in version control
 *      - i also don't think cron needs to be able to help users edit other
 *        folks crontabs when they could just "su" over and do it themselves
 *      - but, crontab should still be able to list an active crontab, delete
 *        any specific one, take a new/updated one or over stdin
 *
 *   crontab naming...
 *      - usually crontabs are named after the users that submit them, but i
 *        like dillon's idea that a user should be able to have multiple
 *      - with that idea, names could be named anything, but i like the idea of
 *        doing "<username>.<description>" so that they sort easily
 *
 *   security changes...
 *      - do not take any names with any characters outside a very basic range,
 *        meaning [A-Za-z0-9_], not even a dash, no spaces, nothing else
 *      - length of names are restricted to avoid potential issuse, so we are
 *        going to start with 50 characters
 *
 *
 */
/*===[[ SECURITY ]]============================================================*

 *   below is a list of security alerts relating to cron packages
 *
 *   2009-06 ubuntu
 *      - did not properly check setgid and initgroups return codes
 *      - could lead to security escalation
 *
 *   1996-12 department of energy
 *      - buffer overrun potential reading CLI from users
 *      - buffer overrun potential on setting environment variables
 *      - local users can gain root privileges
 *
 *   2000-11 all
 *      - crontab directory not secured from users so they can update crontabs
 *      - local users can gain root privileges
 *      * properly secure /var/spool/cron to 0700 (instead of 0755)
 *
 *   2007-10 aix
 *      - buffer overrun on reading crontabs
 *      - local users can gain root privileges
 *      * limit line length and number of lines to prevent hacking !!!
 *
 *   2001-01 freebsd
 *      - users can use crontab to read other folks crontabs
 *      - security violation and potential updates allowing privilege escalation
 *      * properly secure /var/spool/cron to 0700 (instead of 0755)
 *
 *   2001-05 vixie-cron
 *      - crontab does not drop privileges before allowing crontab editing
 *      - security violation and potential updates allowing privilege escalation
 *      * do not allow editing of crontabs with crontab (traceability issue) !!!
 *
 *   unknown
 *      - cron missets environment variable and sends mail to wrong address
 *      - security violation and potential loss of access/secured information
 *      * do not allow the setting of environment variables !!!
 *
 */
/*===[[ TODOS ]]===============================================================*

 *   TODO : handle system time changes -- look at dcron's logic
 *   metis § · · · · · § khaos output format provided
 *   metis § · · · · · § automatically use --daemon mode if none provided
 *   metis § · · · · · § --fix able to install spool directory if not existing
 *   metis § · · · · · § next run time provided on reporting
 *   metis § · · · · · § maybe use limits like -- min, lower, avg, upper, max
 *
 */
/*===[[ END HDOC ]]===========================================================*/


/*===[[ HEADER GUARD ]]=======================================================*/
#ifndef YKHRONOS_hguard
#define YKHRONOS_hguard loaded




/*345678901-12345678901-12345678901-12345678901-12345678901-12345678901-12345678901-12345678901-*/


/*===[[ PRIVATE HEADERS ]]====================================================*/
/*---(always)---------------*/
#include    <yLOG.h>              /* heatherly logger                         */
#include    <yURG.h>              /* heatherly debugging framework            */
/*---(common)---------------*/
#include    <ySTR.h>              /* heatherly safe string library            */
#include    <yPARSE.h>            /* heatherly file parsing                   */
/*---(optional)-------------*/
#include    <yDLST.h>             /* heatherly specialty 4:2 list w/deps      */
#include    <yEXEC.h>             /* heatherly process control                */
#include    <yJOBS.h>             /* heatherly job execution and control      */
#include    <yREGEX.h>            /* heatherly regular expressions            */
#include    <ySCHED.h>            /* heatherly kernighan scheduling           */
#include    <yCOLOR_solo.h>
/*---(done)-----------------*/



/*===[[ PUBLIC HEADERS ]]=====================================================*/
/*---(big standards)------------*/
#include    <stdio.h>             /* printf, scanf                            */
#include    <stdlib.h>            /* exit, system, ...                        */
#include    <unistd.h>
#include    <sys/unistd.h>        /* fork, execl, getpid, getuid              */
#include    <string.h>            /* strcat, strcpy, strlen, ...              */

/*---(process)------------------*/
#include    <sys/wait.h>          /* sigaction, waitpid, wait4                */
#include    <sys/resource.h>      /* getrusage                                */
#include    <errno.h>             /* errno                                    */

/*---(timekeeping)--------------*/
#include    <time.h>              /* time, localtime, strftime, ...           */
#include    <sys/time.h>          /* gettimeofday                             */

/*---(filesystems)--------------*/
#include    <fcntl.h>             /* open                                     */
#include    <sys/stat.h>          /* fstat, umask                             */
#include    <dirent.h>
#include    <sys/ioctl.h>

/*---(users)--------------------*/
#include    <pwd.h>               /* getpwuid, getpwnam                       */
#include    <grp.h>               /* initgroups                               */

/*---(others)-------------------*/
#include    <sys/types.h>
#include    <stdarg.h>
#define     _XOPEN_SOURCE
#include    <err.h>
#include    <ctype.h>



/*345678901-12345678901-12345678901-12345678901-12345678901-12345678901-123456*/
/*---(communcation files)---------------------------------------*/
#define     DIR_CONF                "/etc/"
#define     DIR_RUN                 "/var/run/"
#define     DIR_LOG                 "/var/log/"
#define     DIR_YLOG                "/var/log/yLOG/"
#define     DIR_YHIST               "/var/log/yLOG.historical/"
#define     DIR_CENTRAL             "/var/spool/khronos/"

#define     DIR_UNIT                "/tmp/"



#define     FILE_HEARTBEAT          "khronos.heartbeat"
#define     FILE_TRACK              "khronos.tracking"
#define     FILE_STATUS             "khronos.status"



 /*===[[ ACTIONS ]]=============================*/
/*---(local)----------------*/
#define     ACT_VERIFY      'v'
#define     ACT_VVERIFY     'V'
#define     ACT_CVERIFY     'ÿ'
/*---(incomming)------------*/
#define     ACT_INSTALL     'i'
#define     ACT_VINSTALL    'I'
#define     ACT_CINSTALL    'ð'
/*---(central/installed)----*/
#define     ACT_COUNT       'l'
#define     ACT_LIST        'L'
#define     ACT_CHECK       'c'
#define     ACT_VCHECK      'C'
#define     ACT_CCHECK      'ý'
/*---(central/security)-----*/
#define     ACT_AUDIT       'a'
#define     ACT_VAUDIT      'A'
#define     ACT_CAUDIT      'è'
#define     ACT_FULLCHECK   'f'
/*---(outgoing)-------------*/
#define     ACT_REMOVE      'r'
#define     ACT_VREMOVE     'R'
#define     ACT_CREMOVE     'ø'

#define     ACT_RELOAD      'H'


#define     ACT_PURGE       'p'
#define     ACT_HUP         'H'

#define     ACT_LOAD        'L'
#define     ACT_NONE        '-'
#define     ACT_ALL         "pliLH-"

#define     ACT_NEW         'N'
#define     ACT_DEL         'D'

/*---(work files and directories)-------------------------------*/
#define    PATH          "/sbin:/bin:/usr/sbin:/usr/bin:/opt/sbin:/opt/bin:/usr/local/sbin:/usr/local/bin"
#define    SHELL         "/bin/dash"


/*345678901-12345678901-12345678901-12345678901-12345678901-12345678901-123456*/









#define    HOUR          3600     /* seconds per hour */


#define    MODE_USER     'i'
#define    MODE_DAEMON   'd'
#define    MODE_UNIT     'u'


#define    FILE_ACTIVE   '-'
#define    FILE_RETIRE   'y'
#define    FILE_REPLACE  'R'



/*---(debugging)-------------------------*/
#define     TEST        if (testing     == 'y')
extern      char        testing;
extern      int         failed;
extern      char        g_seq;


extern      char        unit_answer [LEN_RECD];
extern      char      verstring    [500];


/*---(convienence typedefs)-------------------------------------*/
typedef const int        cint;
typedef unsigned int     uint;
typedef const long       clong;
typedef const char       cchar;

/*---(structure short names)------------------------------------*/
typedef struct stat      tSTAT;
typedef struct passwd    tPASSWD;
typedef struct tm        tTIME;
typedef struct dirent    tDIRENT;


typedef struct cFILE     tFILE;
typedef struct cLINE     tLINE;
/*---(structures)-----------------------------------------------*/



struct cACCESSOR
{
   /*---(files)----------------*/
   char        run_as;                      /* khronos, eos, heracles, ...    */
   char        run_mode;                    /* verify, install, audit, ...    */
   char        run_file    [LEN_PATH];      /* file to act on                 */
   /*---(warnings)-------------*/
   char        alt_dir;                     /* use of dir central             */
   /*---(current time)---------*/
   long        now;                         /* current epoch                  */
   long        clean;                       /* current epoch (start of hour)  */
   int         year;                        /* current year                   */
   int         month;                       /* current month                  */
   int         day;                         /* current day                    */
   int         hour;                        /* current hour                   */
   int         minute;                      /* current minute                 */
   char        heartbeat      [LEN_HUND];   /* latest heartbeat               */
   /*---(files)----------------*/
   char        n_central   [LEN_PATH];      /* crontabs global directory      */
   char        n_home      [LEN_PATH];      /* home directory                 */
   char        n_root      [LEN_PATH];      /* root directory                 */
   char        n_heartbeat [LEN_PATH];      /* pulser file name               */
   char        n_track     [LEN_PATH];      /* job tracker file name          */
   char        n_status    [LEN_PATH];      /* status update file name        */
   /*---(pulse)----------------*/
   char        pulse_time   [ 50]; /* last time string written to pulse       */
   char        pulse_begin  [ 50]; /* start of this cron run as string        */
   char        pulse_end    [ 50]; /* ending of last cron run as string       */
   /*---(main identifiers)-----*/
   char        m_prog      [LEN_DESC];      /* program name called            */
   char        m_who       [LEN_USER];      /* caller user name               */
   int         m_uid;                       /* caller user id                 */
   char        m_root;                      /* is caller root (y/-)           */
   int         m_pid;                       /* process id of khronos          */
   int         m_ppid;                      /* parent process id of khronos   */
   char        m_path      [LEN_PATH];      /* run-time path                  */
   /*---(files)----------------*/
   char        f_path      [LEN_PATH];      /* crontab file path              */
   char        f_ready;                     /* crontab name checks out        */
   char        f_name      [LEN_HUND];      /* crontab file name              */
   char        f_user      [LEN_USER];      /* crontab user name              */
   int         f_uid;                       /* crontab execution uid          */
   char        f_desc      [LEN_DESC];      /* crontab description            */
   char        f_dir       [LEN_PATH];      /* current file path              */
   char        f_full      [LEN_RECD];      /* crontab fully qualified name   */
   char        f_ext       [LEN_SHORT];     /* crontab extention              */
   char        f_new       [LEN_HUND];      /* crontab installed name         */
   /*---(file deprecated)------*/
   char        name        [LEN_HUND];      /* name of the current crontab    */
   char        action      [LEN_SHORT];     /* crontab action requested       */
   char        full        [LEN_RECD];      /* full name (path and all)       */
   /*---(lines)----------------*/
   char        t_ready;                     /* task line checks out           */
   int         t_recdno;                    /* task line number in crontab    */
   char        t_schedule  [LEN_RECD];      /* task schedule requested        */
   char        t_tracker   [LEN_TITLE];     /* task name                      */
   char        t_duration  [LEN_TERSE];     /* task estimated dur in secs     */
   char        t_flags     [LEN_LABEL];     /* task behavior flags            */
   char        t_command   [LEN_FULL];      /* task command to execute        */
   /*---(working variables)----*/
   char        parsed      [LEN_HUND];      /* representation of the results of parsing  */
   long        fast_beg;                    /* current fast list start        */
   /*---(context info)---------*/
   int         for_line;                    /* line which uses context (next one)        */
   long        last_end;                    /* last end                       */
   long        this_start;                  /* present start                  */
   /*---(scheduling)--------*/
   char        s_min       [LEN_LONG];      /* minutes           0-59         */
   char        s_hrs       [LEN_TITLE];     /* hours             0-23         */
   char        s_dys       [LEN_DESC];      /* days of month     1-31         */
   char        s_mos       [LEN_LABEL];     /* month of year     1-12         */
   char        s_dow       [LEN_TERSE];     /* day of week       1-7          */
   char        s_wks       [LEN_LONG];      /* week of year      1-53         */
   char        s_yrs       [LEN_LONG];      /* years             1-50         */
   char        s_beg       [LEN_TERSE];     /* beg of validity                */
   char        s_end       [LEN_TERSE];     /* end of validity                */
   char        s_valid;                     /* valid for current day          */
   /*---(trigger)--------------*/
   char        resync;                      /* update crontabs : n=not, -=marked, a=all  */
};
extern    struct cACCESSOR my;


struct cFILE {
   /*---(master)---------------*/
   char        seq;                         /* unique id for testing          */
   char        title       [LEN_HUND];      /* name of the cronfile           */
   char        user        [LEN_USER];      /* execution user name            */
   int         uid;                         /* execution user uid             */
   char        note        [LEN_TERSE];     /* processing note for sysadmin   */
   int         lines;                       /* number of lines attempted      */
   int         valid;                       /* currently valid/active         */
   char        retired;                     /* special file of retired lines  */
   /*---(done)-----------------*/
};

struct cLINE {
   /*---(master)---------------*/
   char        tracker     [LEN_TITLE];     /* description of task            */
   int         recdno;                      /* line number in crontab         */
   void       *sched;                       /* schedule structure             */
   char        command     [LEN_RECD];      /* shell command                  */
   /*---(working)--------------*/
   char        retire;                      /* line no longer in use          */
   int         rpid;                        /* pid if executing               */
   int         start;                       /* time started                   */
   char        force;                       /* force term/kill                */
   /*---(estimates)------------*/
   int         est;                         /* expected duration from ysched  */
   int         est_min;                     /* calculated min duration        */
   int         est_max;                     /* calculated max duration        */
   /*---(flags)----------------*/
   char        value;                       /* how critical is the job        */
   char        track;                       /* how tightly to monitor         */
   char        handoff;                     /* handoff to kharon/haides       */
   char        strict;                      /* strictness of limits           */
   char        lower;
   char        upper;
   char        remedy;                      /* limit violation remedy         */
   /*---(extended)-------------*/
   char        flex;
   char        throttle;
   char        cpu;
   char        disk;
   char        net;
   /*---(previous)-------------*/
   int         l_rpid;
   int         l_beg;
   int         l_end;
   int         l_dur;
   char        l_yexec;
   char        l_rc;
   /*---(counts)---------------*/
   char        c_runs;
   char        c_skip;
   char        c_badd;
   char        c_boom;
   char        c_kill;
   char        c_shut;
   char        c_fail;
   char        c_pass;
   char        c_earl;
   char        c_late;
   /*---(done)-----------------*/
};

#define  T_BEG         '['
#define  T_RUN         'r'
#define  T_SKIP        's'
#define  T_BADD        'b'
#define  T_BOOM        'o'
#define  T_KILL        'k'
#define  T_SHUT        'x'
#define  T_FAIL        'f'
#define  T_PASS        'p'
#define  T_EARL        'e'
#define  T_LATE        'l'
#define  T_END         ']'





/*---(prototypes)-----------------------------------------------*/

int         main               (int argc, char *argv[]);


/*===[[ KHRONOS_PROG.C ]]=====================================================*/
/*---(utility)--------------*/
char        wait_minute        (void);
/*> char        catchup            (void);                                            <*/
/*345678901-12345678901-12345678901-12345678901-12345678901-12345678901-123456*/
/*---(program)--------------*/
char*       PROG_version            (void);
char        PROG_vershow            (void);
/*---(preinit)--------------*/
char        PROG__header            (void);
char        PROG_urgents            (int a_argc, char *a_argv []);
/*---(startup)--------------*/
char        PROG__files_normal      (void);
char        PROG__files_unit        (void);
char        PROG__init              (int a_argc, char *a_argv[]);
char        PROG__args              (int a_argc, char *a_argv[]);
char        PROG__begin             (void);
char        PROG_startup            (int a_argc, char *a_argv[]);
/*---(shutdown)-------------*/
char        PROG_term               (void);
char        PROG__end               (void);
char        PROG_shutdown           (void);
/*---(done)-----------------*/

/*---(unit testing)---------*/
char*       prog__unit              (char *a_question);
char        PROG__unit_prepare      (void);
char        PROG__unit_cleanup      (void);
char        prog__unit_quiet        (void);
char        prog__unit_loud         (void);
char        prog__unit_end          (void);




/*---(program)--------------*/
char        BASE_init               (void);
char        BASE__purge             (char a_type);
char        BASE_wrap               (void);
char        BASE_purge              (void);
char        BASE_prune              (void);
char        BASE_retire             (void);

char        context                 (int, cchar*);
char        parse                   (char*, char *, int, int, char*);
int         convert                 (cchar*, cchar*, cint, cint);
char        BASE_unitfile           (void);
char        BASE_unitproc           (void);
char        BASE_unitfast           (void);
char        BASE_unitshape          (char*);









/*===[[ KHRONOS_TABS.C ]]======================================*/
/*---support-----------*/
/*> char        tabs__verify            (cchar *a_full);                              <*/
/*> char        tabs__remove            (cchar *a_full);                              <*/
/*---specialty---------*/
char        tabs_hup                (void);
char        crontab_help       (void);
/*345678901-12345678901-12345678901-12345678901-12345678901-12345678901-123456*/
/*---stubs-------------*/
/*> char        tabs_cat_stub           (void);                                       <*/
/*> char        tabs_dir_stub           (void);                                       <*/
/*> char        tabs_stdin_stub         (void);                                       <*/
/*> char        tabs_edit_stub          (void);                                       <*/
/*> char*       tabs__unit              (char *a_question, int a_num);                <*/



char        data_retire             (void);



/*---(support)--------------*/
char        FILE__wipe              (tFILE *a_cur);
char*       FILE__memory            (tFILE *a_cur);
/*---(memory)---------------*/
char        FILE__new               (tFILE **a_new);
char        FILE__free              (tFILE **a_old);
/*---(support)--------------*/
char        FILE_create             (char *a_name, char *a_user, int a_uid);
char        FILE_delete             (char *a_name);
char        FILE_pull               (cchar *a_full);
char        FILE_pull_detail        (cchar a_loc, cchar *a_full, cchar *a_name, cchar *a_fuser, int a_fuid);
char        FILE_assimilate         (cchar a_runas, cchar a_loc, cchar *a_name, char *r_user, char *r_desc);
/*---(retire)---------------*/
/*> char        FILE_prune              (void);                                       <*/
/*> char        FILE_retire             (char *a_name);                               <*/
/*> char        FILE_flush              (void);                                       <*/
/*---(unittest)-------------*/
char*       file__unit              (char *a_question, int a_num);


char        file_destroy            (void);
char        file_retire_scan        (void);
char        file_retire             (void);


/*===[[ KHRONOS_LINE.C ]]=====================================================*/
/*345678901-12345678901-12345678901-12345678901-12345678901-12345678901-123456*/
/*---(memory)---------------*/
char        LINE__wipe              (tLINE *a_cur);
char*       LINE__memory            (tLINE *a_cur);
char        LINE__new               (tLINE **a_new);
char        LINE_dup                (tLINE *a_orig, tLINE **a_new);
char        LINE__free              (tLINE **a_old);
/*---(handler)--------------*/
char        LINE__prepare           (void);
char        LINE__original          (int n, uchar *a_verb);
char        LINE__revised           (int n, uchar *a_verb, int c);
char        LINE__populate          (tLINE *a_new, int n, char *a_schedule, char *a_tracker, char *a_duration, char *a_flags, char *a_command);
char        LINE__create            (int n, char *a_schedule, char *a_tracker, char *a_duration, char *a_flags, char *a_command);
char        LINE_handler            (int n, uchar *a_verb, char a_exist, void *a_handler);
/*---(mass)-----------------*/
int         LINE__purge             (char a_scope, char a_type);
int         LINE_purge_global       (void);
int         LINE_prune_global       (void);
int         LINE_retire_global      (void);
/*> int         LINE_purge_local        (void);                                       <*/
/*> int         LINE_prune_local        (void);                                       <*/
/*> int         LINE_retire_local       (void);                                       <*/
/*---(unittest)-------------*/
char        LINE_setrpid            (char *a_file, char *a_line, int a_rpid);
/*---(done)-----------------*/


/*345678901-12345678901-12345678901-12345678901-12345678901-12345678901-123456*/
/*---(signals)--------------*/
void        EXEC_comm               (int a_signal, siginfo_t *a_info, char *a_name, char *a_desc);
char        EXEC_linekill           (char *a_file, char *a_line, char a_sig);
/*---(marking)--------------*/
char        EXEC_mark_done          (char a_yexec, int a_return);
/*---(timekeep)-------------*/
long        EXEC_time               (long a_now);
char        EXEC_wait_min           (void);
/*---(hour)-----------------*/
char        EXEC_every_hour         (int a_hour);
int         EXEC_focus              (void);
/*---(minute)---------------*/
char        EXEC_every_min          (int a_min);
int         EXEC_check              (void);
char        EXEC_dispatch           (int a_min);
/*---(unittest)-------------*/
char*       exec__unit              (char *a_question, int a_num);
/*---(done)-----------------*/

char        BASE_execute            (void);
char        base_daemon             (void);

char        RPTG_track_exec         (tFILE *a_file, tLINE *a_line, char a_reason, char a_note);
char        rptg__track_ends        (char a_sig, char *a_name, char *a_desc);
char        RPTG_track_beg          (void);
char        RPTG_track_end          (void);
char        RPTG_track_sig          (char a_sig, char *a_name, char *a_desc);
char        RPTG_minute__open       (FILE **f);
char        RPTG_minute__close      (FILE **f);
char        RPTG_minute__header     (FILE *f);
char        RPTG_minute__footer     (FILE *f, int c);
char        RPTG_minute             (void);
char        RPTG_by_min__prepare    (void);
char        RPTG_by_min__header     (FILE *f, char a_color, char *a_name, char a_beg, char a_end);
char        RPTG_by_min__hour       (char a_color, int n, tLINE *x_line, char a_yr, char a_mo, char a_dy, char a_hr, char *a_out);
char        RPTG_by_min__line       (FILE *f, char a_color, int n, tLINE *a_line, char a_yr, char a_mo, char a_dy, char a_hr, char a_count);
char        RPTG_by_min__block      (FILE *f, char a_color, char a_yr, char a_mo, char a_dy, char a_beg, char a_count);
char        RPTG_by_min__offset     (long a_epoch, cchar a_yr, cchar a_mo, cchar a_dy, int a_offset, long *r_epoch, char *r_yr, char *r_mo, char *r_dy);
char        RPTG_by_min_direct      (FILE *f, char a_color, char a_yr, char a_mo, char a_dy);
char*       rptg__unit              (char *a_question, int a_num);

char        khronos_yjobs           (cchar a_req, cchar *a_data);

#endif
/*=============================[[ end-of-code ]]==============================*/
